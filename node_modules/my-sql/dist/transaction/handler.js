'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _worker = require('./worker');

var _worker2 = _interopRequireDefault(_worker);

var _dbManager = require('../dbManager');

var _dbManager2 = _interopRequireDefault(_dbManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Handle the execution of transactions
 */
/**
 * Created by pubudud on 8/30/17.
 */

class TransactionHandler {

    /**
     * Execute a transaction with any given number of queries
     *
     * @param {Object} options - transaction options.
     *      @param {string} [options.pool = DEFAULT] - Mysql connection pool type.
     *      @param {Object[]} options.queries - Object array of query and args pairs -> [{query: query, args:args}^n].
     * @returns {Promise} - Transactions results as an object
     */
    executeTransaction(options) {
        return new Promise((resolve, reject) => {

            const connectionPool = _dbManager2.default.getConnectionPool(options.pool);

            // Check if the specified pool is a valid one
            if (!connectionPool) {
                const err = new Error('Invalid pool type');
                err.appendDetails('TransactionHandler', 'executeQuery', `Pool: ${options.pool}`);
                return reject(err);
            }

            connectionPool.getConnection((err, conn) => {
                if (err) {
                    err.appendDetails('TransactionHandler', 'executeTransaction', '[MySQL]Error getting connection from pool');
                    return reject(err);
                }
                conn.beginTransaction(err => {
                    if (err) {
                        err.appendDetails('TransactionHandler', 'executeTransaction', '[MySQL]Error starting transaction');
                        conn.release();
                        return reject(err);
                    }

                    _worker2.default.executeOrRollbackLoop(conn, options.queries, 0).then(results => {
                        conn.release();
                        return resolve(results);
                    }).catch(err => {
                        err.appendDetails('TransactionHandler', 'executeTransaction', '[MySQL]Failed to complete transaction');
                        conn.release();
                        return reject(err);
                    });
                });
            });
        });
    }
}

exports.default = new TransactionHandler();